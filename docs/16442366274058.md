# Kotlin Coroutines（三）

# Channel and Flow

## Channel

Channel 被添加为协程间通信的基元。它支持任意数量的接受者和发送者，并且每一个发送到 channel 的数据都会被接收一次。

![Snipaste_2022-02-17_16-54-12](media/16442366274058/Snipaste_2022-02-17_16-54-12.png)

Channel 是一个接口，它实现了另外两个接口：

* SendChannel：发送元素，关闭 channel
* ReceiveChannel：接收元素

```kotlin
1  interface SendChannel<in E> {
2       suspend fun send(element: E)
3       fun close(): Boolean
4}
5
6  interface ReceiveChannel<out E> {
7       suspend fun receive(): E
8}
9
10  interface Channel<E> : SendChannel<E>, ReceiveChannel<E>
```
你可能注意到，send 和 receive 都是挂起函数：

* 当我们试图接收时，如果 channel 中没有元素，那么协程就会被挂起，直到元素可用。
* 另一方面，当 channel 达到其容量时，send 也会被挂起

一个channel可以有多个生产者和消费者。大多情况下都是一个生产者和一个消费者。

![Snipaste_2022-02-17_19-44-57](media/16442366274058/Snipaste_2022-02-17_19-44-57.png)

一个简单的例子：

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = Channel<Int>()
    launch {
        repeat(5) { index ->
            println("Producing next one")
            delay(1000)
            channel.send(index)
        }
    }

    launch {
        repeat(5) {
            val received = channel.receive()
            println(received)
        }
    }
}
// Producing next one
// Producing next one
// 0
// Producing next one
// 1
// Producing next one
// 2
// Producing next one
// 3
// 4
```

这个实现远远不够完美。首先，接收方需要知道有多少个元素将要发送。这种情况很少发生，我们更倾向于只要发送方愿意发送就监听，直到它被关闭，可以使用for循环或 consumeEach 函数。

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = Channel<Int>()
    launch {
        repeat(5) { index ->
            println("Producing next one")
            delay(1000)
            channel.send(index)
        }
        channel.close()
    }

    launch {
        for (element in channel) {
            println(element)
        }
    }
}
```

使用这种方式发送数据的常见问题就是容易忘记关闭通道。这样很容易出现一些异常。一个很方便的方法是使用 produce 方法，他会返回一个 ReceiveChannel

```kotlin
fun CoroutineScope.produceNumbers(): ReceiveChannel<Int> = 
    produce {
        var x = 0
        while(true) send(x++)
    }
```

当协程以任何方式结束，produce 方法都会关闭 channel。

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = produce {
        repeat(5) { index ->
            println("Producing next one")
            delay(1000)
            send(index * 2)
        }
    }

    launch {
        for (element in channel) {
            println(element)
        }
    }
}
```

### Channel types

根据设置容量的大小，区分了四种类型的 channel

* **Unlimited**：容量为 Channel.UNLIMITED的 channel，它有无限的缓冲容量，并且发送永远不会挂起
* **Buffered**：容量为具体的或者 Channel.BUFFERED（默认为64）
* **Rendezvous**(默认)：容量为 0 或者 Channel.RENDEZVOUS，这意味着只有当发送方和接收方相遇时，交换才能发生。这意味着当等待另一个人的时候，至少会被暂停一段时间。
* **Conflated**：容量为 Channel.CONFLATED，有一个大小为1的缓冲区，每个新的元素都会取代前一个元素。

我们让快速生产，缓慢消费。通过 unlimited，channel 会接受所有的元素，然后让它们一个接一个地被接收

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = produce(capacity = Channel.UNLIMITED) {
        repeat(5) { index ->
            send(index * 2)
            delay(100)
            println("Sent")
        }
    }
    delay(1000)

    for (element in channel) {
        println(element)
        delay(1000)
    }
}
// Sent
// (0.1 sec)
// Sent
// (0.1 sec)
// Sent
// (0.1 sec)
// Sent
// (0.1 sec)
// Sent
// (1 - 4 * 0.1 = 0.6 sec)
// 0
// (1 sec)
// 2
// (1 sec)
// 4
// (1 sec)
// 6
// (1 sec)
// 8
// (1 sec)
```

通过具体的容量，一开始会生产的很快直到缓冲区变满为止，接着生产者会等待消费者。

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = produce(capacity = 3) {
        repeat(5) { index ->
            send(index * 2)
            delay(100)
            println("Sent")
        }
    }
    delay(1000)

    for (element in channel) {
        println(element)
        delay(1000)
    }
}
// Sent
// (0.1 sec)
// Sent
// (0.1 sec)
// Sent
// (1 - 2 * 0.1 = 0.8 sec)
// 0
// Sent
// (1 sec)
// 2
// Sent
// (1 sec)
// 4
// (1 sec)
// 6
// (1 sec)
// 8
// (1 sec)
```

默认容量的 channel，一开始生产者就会等待消费者。

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = produce(capacity = Channel.RENDEZVOUS) {
        repeat(5) { index ->
            send(index * 2)
            delay(100)
            println("Sent")
        }
    }
    delay(1000)

    for (element in channel) {
        println(element)
        delay(1000)
    }
}
0
Sent
2
Sent
4
Sent
6
Sent
8
Sent
```

conflated ，不会存储之前的元素，新的元素会代替之前的元素，所以只会接收到最后一个元素。

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = produce(capacity = Channel.CONFLATED) {
        repeat(5) { index ->
            send(index * 2)
            delay(100)
            println("Sent")
        }
    }
    delay(1000)

    for (element in channel) {
        println(element)
        delay(1000)
    }
}
Sent
Sent
Sent
Sent
Sent
8
```