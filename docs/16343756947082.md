# 进程间通信——Binder

**Service Manager 在 Binder 通行过程中的唯一标志都是0。**

![IMG_0145](media/16343756947082/IMG_0145.JPG)
 

## 1. 智能指针

### 1.1 智能指针的设计理念

C/C++ 项目中常见的指针问题：

* 指针没有初始化
* new 了对象后没有及时 delete
* 野指针

智能指针设计，SmartPointer 类：

* SmartPointer 是个类，有一个指针变量指向 object
```C++
class SmartPointer{
        private:
        void *m_ptr;  // 指向 object
};
```

* SmartPointer 是一个模板类

```C++
template<typename T>
class SmartPointer {
private:
    T *m_ptr;   // 指向 object
};
```

* SmartPointer 构造函数应将 m_ptr 置空

```C++
template<typename T>
class SmartPointer {
private:
    inline SmartPointer() : m_ptr(0)

    T *m_ptr;   // 指向 object
};
```

* 引用计数，一个计数器记录该内对对象”被需要“的个数即可，当这个计数器递减到零时，说明该内存对象可以被回收了。


#### 计数器应由 object 自身持有


```C++
template<class T>
class LightRefBase{
public:
    inline LightRefBase():mCount(0){}
    inline void incStrong() const {
        // 增加引用计数
        android_atomic_inc(&mCount);
    }
    inline void desStrong() const{
        if(android_atomic_dec(&mCount) == 1) {
            // 减小引用计数
            delete static_cast<const T*>(this)  // 删除内存对象
        }
    }
protected:
    inline ~LightRefBase(){}
private:
    mutable volatile int32_t mCount;    // 引用计数值
};
```

**LightRefBase** 类主要提供两个方法，即 incStrong 和 decStrong，分别用于增加和减少引用计数值，当没有引用内存对象，还需要自动释放自己。

当一个智能指针应用了 object 时，其父类中的 incStrong 就会被调用，这意味着 SmartPointer 必须要重载它的 ”=“ 运算符。

```C++
template<typename T>
SmartPointer<T> &SmartPointer<T>::operate = (T * other) {
    if(other!=null) {
        m_ptr = other;
        other->incStrong();
    }
    return *this;
}
```

当 SmartPointer 析构时，也应及时调用 decStrong 来释放引用

```C++
template<typename T>
wp<T>::~wp() {
    if(m_ptr) m_ptr->decStrong();
}
```

![IMG_0218](media/16343756947082/IMG_0218.JPG)

#### 1.2 强指针 sp

**sp:StrongPointer**

```C++
template<typename T>
class sp {
public:
    inline sp() : m_ptr(nullptr) { }
    
    sp(T* other);   // 常用构造函数

    // 其他构造函数
    sp(const sp<T>& other);
    sp(sp<T>&& other) noexcept;
    
    ~sp();  // 析构函数

    // Accessors

    inline T&       operator* () const     { return *m_ptr; }
    inline T*       operator-> () const    { return m_ptr;  }
    inline T*       get() const            { return m_ptr; }
    inline explicit operator bool () const { return m_ptr != nullptr; }

private:
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;
    void set_pointer(T* ptr);
    static inline void check_not_on_stack(const void* ptr);
    T* m_ptr;
};
```

它和之前 SmartPointer 类实现上基本是一致的，比如等号运算符：

```C++
template <typename T>
sp<T>& sp<T>::operator=(T* other) {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    if (other) {
        check_not_on_stack(other);
        other->incStrong(this);
    }
    if (oldPtr) oldPtr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = other;
    return *this;
}
```

#### 1.3 弱指针

为了解决对象间相互引用时对象不能释放的问题。

![IMG_0219](media/16343756947082/IMG_0219.JPG)

CDad 使用强指针来引用 CChild，而 CChild 只使用弱引用来指向父类。

当强引用数为 0 时，不论弱引用是否为 0 都可以 delete 自己。

**弱指针必须先升级为强指针，才能访问它指向的目标对象。**

```C++
template <typename T>
class wp
{
public:
    typedef typename RefBase::weakref_type weakref_type;

    inline wp() : m_ptr(nullptr), m_refs(nullptr) { }
    
    // 构造函数
    wp(T* other);

    wp(const wp<T>& other);

    ~wp();

    // Assignment
    wp& operator = (const wp<T>& other);
    wp& operator = (const sp<T>& other);
    
    void set_object_and_refs(T* other, weakref_type* refs);

    // promotion to sp，升级为强指针
    sp<T> promote() const;


    // Accessors

    inline  weakref_type* get_refs() const { return m_refs; }

    inline  T* unsafe_get() const { return m_ptr; }

    private:
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;

    T*              m_ptr;
    weakref_type*   m_refs;
};
```

和 sp 相比，wp 在类的定义上有如下重要区别：

* 除了指向目标对象的 m_ptr 外，wp 另外一个 m_refs 指针，类型为 weakref_type
* 没有重载 ->,* 等运算符
* 有一个 prmote 方法来将 wp 提升为 sp
* 目标对象的父类不是 LigthRefBase，而是 RefBase

构造函数

```C++
template<typename T>
wp<T>::wp(T* other)
    : m_ptr(other)
{
    m_refs = other ? m_refs = other->createWeak(this) : nullptr;
}
```

wp 并没有直接增加目标对象的引用计数值，而是调用了 createWeak 方法

**RefBase 类**

```C++
class RefBase
{
public:
            void            incStrong(const void* id) const;    // 增加强引用计数值
            void            decStrong(const void* id) const;    // 减少强引用计数值
            ...

    // 嵌套类，wp 中用到的就是这个类
    class weakref_type
    {
    public:
        RefBase*            refBase() const;

        void                incWeak(const void* id);
        void                decWeak(const void* id);
        ... 
    };

            weakref_type*   createWeak(const void* id) const;   // 生成一个 weakref_type
            
            weakref_type*   getWeakRefs() const;

protected:
                            RefBase();  // 构造函数
    virtual                 ~RefBase();
    
    // 用于修改 object 的生命周期
    enum {
        OBJECT_LIFETIME_STRONG  = 0x0000,
        OBJECT_LIFETIME_WEAK    = 0x0001,
        OBJECT_LIFETIME_MASK    = 0x0001
    };
    

private:
        ...
        weakref_impl* const mRefs;
};
```

RefBase 嵌套了一个重要的类 weakref_type，也就是 m_refs 指针所属的类型。

RefBase 中还有一个 mRefs 成员变量，它是 weakref_type 的实现类。

```C++
class RefBase::weakref_impl : public RefBase::weakref_type
{
public:
    std::atomic<int32_t>    mStrong;    //  强引用计数器
    std::atomic<int32_t>    mWeak;  // 弱引用计数器
    RefBase* const          mBase;
    std::atomic<int32_t>    mFlags;

#if !DEBUG_REFS

    explicit weakref_impl(RefBase* base)
        : mStrong(INITIAL_STRONG_VALUE)
        , mWeak(0)
        , mBase(base)
        , mFlags(OBJECT_LIFETIME_STRONG)
    {
    }

    void addStrongRef(const void* /*id*/) { }
    void removeStrongRef(const void* /*id*/) { }

#else

    weakref_impl(RefBase* base)
        : mStrong(INITIAL_STRONG_VALUE)
        , mWeak(0)
        , mBase(base)
        , mFlags(OBJECT_LIFETIME_STRONG)
        , mStrongRefs(NULL)
        , mWeakRefs(NULL)
        , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)
        , mRetain(false)
    {
    }

    ~weakref_impl()
    ...
#endif
};
```

**createWeak 函数**

```C++
RefBase::weakref_type* RefBase::createWeak(const void* id) const
{
    mRefs->incWeak(id); // 增加弱引用计数
    return mRefs;   // 直接返回 weakref_type 对象
}
```
这个函数先增加了 mRefs （也就是 weakref_impl 类型的成员变量）中弱引用计数值，然后返回这个 mRefs。

![IMG_0226](media/16343756947082/IMG_0226.JPG)

在 createWeak 中，mRefs 通过 incWeak 增加了计数器的弱引用

```C++
void RefBase::weakref_type::incWeak(const void* id)
{
    weakref_impl* const impl = static_cast<weakref_impl*>(this);
    impl->addWeakRef(id);
    const int32_t c __unused = impl->mWeak.fetch_add(1,
            std::memory_order_relaxed);
    ALOG_ASSERT(c >= 0, "incWeak called on %p after last weak ref", this);
}
```

当 wp 构造完成后，RefBase 所持有的 weakref_type 计数器中的 mWeak 就为 1，后面如果有新的 wp 执行这个对象，mWeak 还会持续增加。

```C++
void RefBase::incStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    refs->incWeak(id);  // 增加弱引用计数值

    refs->addStrongRef(id);
    const int32_t c = refs->mStrong.fetch_add(1, std::memory_order_relaxed);    // 增加强引用计数值
    ALOG_ASSERT(c > 0, "incStrong() called on %p after last strong ref", refs);
#if PRINT_REFS
    ALOGD("incStrong of %p from %p: cnt=%d\n", this, id, c);
#endif
    if (c != INITIAL_STRONG_VALUE)  {   // 判断是不是第一次
        return;     // 不是第一次，直接返回
    }

    int32_t old __unused = refs->mStrong.fetch_sub(INITIAL_STRONG_VALUE, std::memory_order_relaxed);
    // A decStrong() must still happen after us.
    ALOG_ASSERT(old > INITIAL_STRONG_VALUE, "0x%x too small", old);
    refs->mBase->onFirstRef();
}
```

同时增加弱引用和强引用计数值，还要判断目标对象是不是第一次被引用，其中 c 变量是”增加之前的值“，如果等于 INITIAL_STRONG_VALUE 就说明是第一次，一方面要回调 onFirstRef 通知对象自己被引用,另一方面要对 mStrong 值做下小调整。

```C++
void RefBase::decStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    refs->removeStrongRef(id);
    const int32_t c = refs->mStrong.fetch_sub(1, std::memory_order_release);    // 减少强引用计数
#if PRINT_REFS
    ALOGD("decStrong of %p from %p: cnt=%d\n", this, id, c);
#endif
    LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), "decStrong() called on %p too many times",
            refs);
    if (c == 1) {   // 减少后强引用计数值已经降为 0
        std::atomic_thread_fence(std::memory_order_acquire);
        refs->mBase->onLastStrongRef(id);   // 通知事件
        int32_t flags = refs->mFlags.load(std::memory_order_relaxed);
        if ((flags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;    // 删除对象
            // The destructor does not delete refs in this case.
        }
    }
    
    refs->decWeak(id);  // 减少弱引用计数
}
```

首先减少 mStrong 计数器，如果减少减到 0 （即 c==1 ）,就需要回调 onLastStrongRef 通知这一事件，接着执行删除操作

特别注意，减少强引用计数值同时还要减少弱引用计数值，即最后的 decWeak(id)

```C++
void RefBase::weakref_type::decWeak(const void* id)
{
    weakref_impl* const impl = static_cast<weakref_impl*>(this);
    impl->removeWeakRef(id);
    const int32_t c = impl->mWeak.fetch_sub(1, std::memory_order_release);  // 减少弱引用计数值
    LOG_ALWAYS_FATAL_IF(BAD_WEAK(c), "decWeak called on %p too many times",
            this);
    if (c != 1) return;
    atomic_thread_fence(std::memory_order_acquire);

    int32_t flags = impl->mFlags.load(std::memory_order_relaxed);
    if ((flags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
        // This is the regular lifetime case. The object is destroyed
        // when the last strong reference goes away. Since weakref_impl
        // outlives the object, it is not destroyed in the dtor, and
        // we'll have to do it here.
        if (impl->mStrong.load(std::memory_order_relaxed)
                == INITIAL_STRONG_VALUE) {
            // Decrementing a weak count to zero when object never had a strong
            // reference.  We assume it acquired a weak reference early, e.g.
            // in the constructor, and will eventually be properly destroyed,
            // usually via incrementing and decrementing the strong count.
            // Thus we no longer do anything here.  We log this case, since it
            // seems to be extremely rare, and should not normally occur. We
            // used to deallocate mBase here, so this may now indicate a leak.
            ALOGW("RefBase: Object at %p lost last weak reference "
                    "before it had a strong reference", impl->mBase);
        } else {
            // ALOGV("Freeing refs %p of old RefBase %p\n", this, impl->mBase);
            delete impl;
        }
    } else {
        // This is the OBJECT_LIFETIME_WEAK case. The last weak-reference
        // is gone, we can destroy the object.
        impl->mBase->onLastWeakRef(id);
        delete impl->mBase;
    }
}
```
先减小 mWeak 计数值，若果发现不为 0 （即 c!=1）就直接返回，否则就是弱引用计数值也为0，此时要根据 LIFETIME 标志分别处理。

当(flags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONGS 时，即释放受强引用控制，（在 incStrong 函数，同时增加了强、弱引用计数器，而增加弱引用时是不会同时增加强引用的，这说明弱引用的值一定会大于等于强引用值），当程序走到这里，弱引用计数值一定为 0，而强引用值有两种情况：

* 强引用值为 INITIAL_STRONG_VALUE，说明这个目标没有被强引用过，也就是没有办法靠强指针来释放目标，所以需要 delete impl->mBase
* 有强引用的情况下，此时要 delete impl，而目标对象会由强引用 decStrong 来释放

析构函数

```C++

RefBase::~RefBase()
{
    int32_t flags = mRefs->mFlags.load(std::memory_order_relaxed);
    // Life-time of this object is extended to WEAK, in
    // which case weakref_impl doesn't out-live the object and we
    // can free it now.
    if ((flags & OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) {
        // It's possible that the weak count is not 0 if the object
        // re-acquired a weak reference in its destructor
        if (mRefs->mWeak.load(std::memory_order_relaxed) == 0) {
            delete mRefs;
        }
    } else if (mRefs->mStrong.load(std::memory_order_relaxed) == INITIAL_STRONG_VALUE) {
        // We never acquired a strong reference on this object.
#if DEBUG_REFBASE_DESTRUCTION
        // Treating this as fatal is prone to causing boot loops. For debugging, it's
        // better to treat as non-fatal.
        ALOGD("RefBase: Explicit destruction, weak count = %d (in %p)", mRefs->mWeak.load(), this);

#if CALLSTACK_ENABLED
        CallStack::logStack(LOG_TAG);
#endif
#else
        LOG_ALWAYS_FATAL("RefBase: Explicit destruction, weak count = %d", mRefs->mWeak.load());
#endif
    }
    // For debugging purposes, clear mRefs.  Ineffective against outstanding wp's.
    const_cast<weakref_impl*&>(mRefs) = nullptr;
}
```

在这种情况下，RefBase 既然是由 decStrong 删除的，而从上面 decStrong 的执行顺序上来看 mWeak 的值还不为 0 ，因而并不会被执行。

**小结：**

* 智能指针分为强指针 sp 和弱指针 wp 两种
* 通常情况下目标对象的父类是 RefBase——这个基类提供了一个 weakref_impl 类型的引用计数器，可以同时进行强弱引用的控制（内部由 mStrong 和 mWeak 提供计数）
* 当 incStrong 增加强引用，也会增加弱引用
* 当 incWeak 时只增加弱引用计数
* 使用者可以通过 extendObjectLifetime 设置引用计数器的规则，不同规则下对删除目标对象的时机判断是不一样的
* 使用者可以根据程序需求来选择合适的智能指针类型和计数规则

## 进程间的数据传递载体——Parcel





